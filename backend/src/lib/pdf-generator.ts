/**
 * PDF REPORT GENERATOR
 * 
 * Professional PDF reports for workflow analysis results
 * Brand colors: #667eea (primary purple), #764ba2 (secondary)
 */

import PDFDocument from 'pdfkit';
import type PDFKit from 'pdfkit';
import { AnalysisResult, WorkflowIssue } from './workflow-analyzer';
import { Readable } from 'stream';

// ============================================================================
// BRAND COLORS
// ============================================================================

const COLORS = {
  primary: '#667eea',
  secondary: '#764ba2',
  critical: '#dc2626',    // red
  high: '#ea580c',        // orange
  medium: '#eab308',      // yellow
  low: '#22c55e',         // green
  text: '#1f2937',
  textLight: '#6b7280',
  background: '#f9fafb',
  white: '#ffffff'
};

// ============================================================================
// HELPER: CONVERT HEX TO RGB
// ============================================================================

function hexToRgb(hex: string): [number, number, number] {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!result) return [0, 0, 0];
  return [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16)
  ];
}

// ============================================================================
// HELPER: GET SEVERITY COLOR
// ============================================================================

function getSeverityColor(severity: string): string {
  switch (severity) {
    case 'critical': return COLORS.critical;
    case 'high': return COLORS.high;
    case 'medium': return COLORS.medium;
    case 'low': return COLORS.low;
    default: return COLORS.textLight;
  }
}

// ============================================================================
// HELPER: GET HEALTH SCORE COLOR
// ============================================================================

function getHealthScoreColor(score: number): string {
  if (score >= 90) return COLORS.low;      // Green - Excellent
  if (score >= 75) return COLORS.medium;   // Yellow - Good
  if (score >= 50) return COLORS.high;     // Orange - Needs Attention
  return COLORS.critical;                   // Red - Critical/High Risk
}

// ============================================================================
// HELPER: ADD FOOTER TO CURRENT PAGE
// ============================================================================

function addFooter(doc: PDFKit.PDFDocument) {
  doc.fontSize(9)
     .fillColor(COLORS.textLight)
     .font('Helvetica')
     .text(
       'Generated by GHL Workflow Debugger',
       50,
       doc.page.height - 40,
       {
         width: doc.page.width - 100,
         align: 'center'
       }
     );
}

// ============================================================================
// MAIN PDF GENERATOR FUNCTION
// ============================================================================

export async function generateWorkflowReportPDF(analysis: AnalysisResult): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      // Create PDF document
      const doc = new PDFDocument({
        size: 'LETTER',
        margins: {
          top: 50,
          bottom: 70,  // Increased bottom margin for footer
          left: 50,
          right: 50
        },
        info: {
          Title: `Workflow Analysis Report - ${analysis.workflowName}`,
          Author: 'GHL Workflow Debugger',
          Subject: 'Workflow Health Analysis',
          CreationDate: new Date()
        },
        autoFirstPage: false
      });

      // Buffer to collect PDF data
      const chunks: Buffer[] = [];
      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);
      
      // Add first page
      doc.addPage();

      // ========================================
      // HEADER WITH GRADIENT
      // ========================================
      
      const primaryRgb = hexToRgb(COLORS.primary);
      const secondaryRgb = hexToRgb(COLORS.secondary);
      
      // Create gradient header
      doc.rect(0, 0, doc.page.width, 120)
         .fillColor(COLORS.primary)
         .fill();
      
      // Add logo placeholder (text-based)
      doc.fontSize(24)
         .fillColor(COLORS.white)
         .font('Helvetica-Bold')
         .text('GHL', 50, 40, { width: 100 });
      
      // Report title
      doc.fontSize(28)
         .fillColor(COLORS.white)
         .font('Helvetica-Bold')
         .text('Workflow Analysis Report', 50, 70, { width: doc.page.width - 100 });

      // Move cursor below header
      let currentY = 140;

      // ========================================
      // METADATA SECTION
      // ========================================
      
      doc.fontSize(10)
         .fillColor(COLORS.textLight)
         .font('Helvetica')
         .text(`Generated: ${new Date().toLocaleString('en-US', {
           dateStyle: 'full',
           timeStyle: 'short'
         })}`, 50, currentY);
      
      currentY += 25;

      // Workflow Name and ID
      doc.fontSize(18)
         .fillColor(COLORS.text)
         .font('Helvetica-Bold')
         .text('Workflow:', 50, currentY);
      
      doc.fontSize(16)
         .fillColor(COLORS.text)
         .font('Helvetica')
         .text(analysis.workflowName, 50, currentY + 22, { width: doc.page.width - 100 });
      
      currentY += 50;

      doc.fontSize(10)
         .fillColor(COLORS.textLight)
         .font('Helvetica')
         .text(`Workflow ID: ${analysis.workflowId}`, 50, currentY);
      
      currentY += 35;

      // ========================================
      // HEALTH SCORE - LARGE DISPLAY
      // ========================================
      
      const scoreColor = getHealthScoreColor(analysis.healthScore);
      const scoreRgb = hexToRgb(scoreColor);
      
      // Draw score box
      doc.roundedRect(50, currentY, 200, 100, 10)
         .fillColor(scoreColor)
         .fill();
      
      // Health Score number
      doc.fontSize(48)
         .fillColor(COLORS.white)
         .font('Helvetica-Bold')
         .text(analysis.healthScore.toString(), 50, currentY + 15, {
           width: 200,
           align: 'center'
         });
      
      // "Health Score" label
      doc.fontSize(12)
         .fillColor(COLORS.white)
         .font('Helvetica')
         .text('Health Score', 50, currentY + 70, {
           width: 200,
           align: 'center'
         });
      
      // Grade Badge (next to score)
      const gradeX = 270;
      doc.roundedRect(gradeX, currentY, 200, 100, 10)
         .lineWidth(2)
         .strokeColor(scoreColor)
         .stroke();
      
      doc.fontSize(24)
         .fillColor(scoreColor)
         .font('Helvetica-Bold')
         .text(analysis.grade, gradeX, currentY + 30, {
           width: 200,
           align: 'center'
         });
      
      doc.fontSize(10)
         .fillColor(COLORS.textLight)
         .font('Helvetica')
         .text(`Confidence: ${analysis.confidence}`, gradeX, currentY + 65, {
           width: 200,
           align: 'center'
         });
      
      currentY += 120;

      // ========================================
      // EXECUTIVE SUMMARY
      // ========================================
      
      doc.fontSize(16)
         .fillColor(COLORS.text)
         .font('Helvetica-Bold')
         .text('Executive Summary', 50, currentY);
      
      currentY += 25;

      const summaryText = generateExecutiveSummary(analysis);
      doc.fontSize(11)
         .fillColor(COLORS.text)
         .font('Helvetica')
         .text(summaryText, 50, currentY, {
           width: doc.page.width - 100,
           align: 'left',
           lineGap: 3
         });
      
      currentY += doc.heightOfString(summaryText, { width: doc.page.width - 100 }) + 20;

      // ========================================
      // ISSUE BREAKDOWN CHART
      // ========================================
      
      doc.fontSize(16)
         .fillColor(COLORS.text)
         .font('Helvetica-Bold')
         .text('Issue Breakdown', 50, currentY);
      
      currentY += 25;

      const issueBreakdown = [
        { label: 'Critical', count: analysis.issuesSummary.critical, color: COLORS.critical },
        { label: 'High', count: analysis.issuesSummary.high, color: COLORS.high },
        { label: 'Medium', count: analysis.issuesSummary.medium, color: COLORS.medium },
        { label: 'Low', count: analysis.issuesSummary.low, color: COLORS.low }
      ];

      issueBreakdown.forEach((item, index) => {
        const itemX = 50 + (index * 130);
        const rgb = hexToRgb(item.color);
        
        doc.roundedRect(itemX, currentY, 110, 60, 5)
           .fillColor(item.color)
           .fillOpacity(0.1)
           .fill()
           .fillOpacity(1);
        
        doc.fontSize(24)
           .fillColor(item.color)
           .font('Helvetica-Bold')
           .text(item.count.toString(), itemX, currentY + 10, {
             width: 110,
             align: 'center'
           });
        
        doc.fontSize(10)
           .fillColor(COLORS.text)
           .font('Helvetica')
           .text(item.label, itemX, currentY + 40, {
             width: 110,
             align: 'center'
           });
      });
      
      currentY += 80;

      // ========================================
      // ISSUES TABLE (NEW PAGE IF NEEDED)
      // ========================================
      
      if (currentY > 600) {
        addFooter(doc);
        doc.addPage();
        currentY = 50;
      }

      doc.fontSize(16)
         .fillColor(COLORS.text)
         .font('Helvetica-Bold')
         .text('Detected Issues', 50, currentY);
      
      currentY += 25;

      if (analysis.issues.length === 0) {
        doc.fontSize(11)
           .fillColor(COLORS.textLight)
           .font('Helvetica-Oblique')
           .text('No issues detected. This workflow is in excellent condition!', 50, currentY);
        currentY += 30;
      } else {
        // Draw each issue
        analysis.issues.forEach((issue, index) => {
          // Check if we need a new page
          if (currentY > doc.page.height - 150) {
            addFooter(doc);
            doc.addPage();
            currentY = 50;
          }

          const severityColor = getSeverityColor(issue.type);
          const rgb = hexToRgb(severityColor);
          
          // Issue box
          doc.roundedRect(50, currentY, doc.page.width - 100, 100, 5)
             .lineWidth(1)
             .strokeColor(severityColor)
             .fillColor(COLORS.white)
             .fillAndStroke();
          
          // Severity badge
          doc.roundedRect(55, currentY + 5, 70, 20, 3)
             .fillColor(severityColor)
             .fill();
          
          doc.fontSize(9)
             .fillColor(COLORS.white)
             .font('Helvetica-Bold')
             .text(issue.type.toUpperCase(), 55, currentY + 10, {
               width: 70,
               align: 'center'
             });
          
          // Issue title
          doc.fontSize(12)
             .fillColor(COLORS.text)
             .font('Helvetica-Bold')
             .text(issue.title, 135, currentY + 8, {
               width: doc.page.width - 200
             });
          
          let issueY = currentY + 35;
          
          // Description
          doc.fontSize(10)
             .fillColor(COLORS.text)
             .font('Helvetica')
             .text(issue.description, 60, issueY, {
               width: doc.page.width - 120,
               lineGap: 2
             });
          
          issueY += doc.heightOfString(issue.description, { width: doc.page.width - 120 }) + 10;
          
          // Recommended fix
          doc.fontSize(9)
             .fillColor(COLORS.textLight)
             .font('Helvetica-Bold')
             .text('Fix: ', 60, issueY);
          
          doc.font('Helvetica')
             .text(issue.fix, 85, issueY, {
               width: doc.page.width - 135,
               lineGap: 2
             });
          
          issueY += doc.heightOfString(issue.fix, { width: doc.page.width - 135 }) + 15;
          
          currentY = issueY + 10;
        });
      }

      // ========================================
      // RECOMMENDATIONS SECTION
      // ========================================
      
      if (currentY > doc.page.height - 200) {
        addFooter(doc);
        doc.addPage();
        currentY = 50;
      }

      doc.fontSize(16)
         .fillColor(COLORS.text)
         .font('Helvetica-Bold')
         .text('Recommendations', 50, currentY);
      
      currentY += 25;

      if (analysis.recommendations.length === 0) {
        doc.fontSize(11)
           .fillColor(COLORS.textLight)
           .font('Helvetica-Oblique')
           .text('No specific recommendations at this time.', 50, currentY);
        currentY += 30;
      } else {
        analysis.recommendations.forEach((rec, index) => {
          if (currentY > doc.page.height - 100) {
            addFooter(doc);
            doc.addPage();
            currentY = 50;
          }

          // Bullet point
          doc.fontSize(11)
             .fillColor(COLORS.text)
             .font('Helvetica-Bold')
             .text(`${index + 1}.`, 50, currentY, { width: 20 });
          
          doc.font('Helvetica')
             .text(rec, 75, currentY, {
               width: doc.page.width - 125,
               lineGap: 3
             });
          
          currentY += doc.heightOfString(rec, { width: doc.page.width - 125 }) + 12;
        });
      }

      // ========================================
      // PERFORMANCE METRICS
      // ========================================
      
      if (currentY > doc.page.height - 200) {
        addFooter(doc);
        doc.addPage();
        currentY = 50;
      }

      currentY += 10;

      doc.fontSize(16)
         .fillColor(COLORS.text)
         .font('Helvetica-Bold')
         .text('Performance Metrics', 50, currentY);
      
      currentY += 25;

      const perfMetrics = [
        { label: 'Estimated Steps', value: analysis.performance.estimatedSteps.toString() },
        { label: 'Estimated Time', value: analysis.performance.estimatedTime },
        { label: 'Complexity', value: analysis.performance.complexity.replace('_', ' ').toUpperCase() },
        { label: 'Bottlenecks', value: analysis.performance.bottlenecks.length > 0 
            ? analysis.performance.bottlenecks.join(', ') 
            : 'None detected' }
      ];

      perfMetrics.forEach((metric) => {
        doc.fontSize(10)
           .fillColor(COLORS.textLight)
           .font('Helvetica-Bold')
           .text(`${metric.label}:`, 50, currentY, { continued: true })
           .font('Helvetica')
           .fillColor(COLORS.text)
           .text(` ${metric.value}`);
        
        currentY += 18;
      });

      // ========================================
      // FOOTER (Add to last page)
      // ========================================
      
      addFooter(doc);

      // Finalize PDF
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

// ============================================================================
// HELPER: GENERATE EXECUTIVE SUMMARY
// ============================================================================

function generateExecutiveSummary(analysis: AnalysisResult): string {
  const parts: string[] = [];
  
  // Opening statement
  const statusWord = analysis.healthScore >= 75 ? 'healthy' : 
                     analysis.healthScore >= 50 ? 'functional but requires attention' :
                     'in need of immediate improvement';
  
  parts.push(
    `This workflow "${analysis.workflowName}" has received a health score of ${analysis.healthScore}/100 (${analysis.grade}), ` +
    `indicating the workflow is ${statusWord}.`
  );
  
  // Issue summary
  if (analysis.issuesSummary.total > 0) {
    const criticalText = analysis.issuesSummary.critical > 0 
      ? `${analysis.issuesSummary.critical} critical issue(s)` 
      : '';
    const highText = analysis.issuesSummary.high > 0 
      ? `${analysis.issuesSummary.high} high-priority issue(s)` 
      : '';
    const mediumText = analysis.issuesSummary.medium > 0 
      ? `${analysis.issuesSummary.medium} medium-priority issue(s)` 
      : '';
    const lowText = analysis.issuesSummary.low > 0 
      ? `${analysis.issuesSummary.low} low-priority issue(s)` 
      : '';
    
    const issueParts = [criticalText, highText, mediumText, lowText].filter(t => t !== '');
    
    parts.push(
      `The analysis detected ${analysis.issuesSummary.total} total issue(s): ` +
      issueParts.join(', ') + '.'
    );
  } else {
    parts.push('No issues were detected in this workflow.');
  }
  
  // Metadata
  parts.push(
    `The workflow contains ${analysis.metadata.totalNodes} node(s) and is currently ` +
    `${analysis.metadata.isActive ? 'active' : 'inactive'}.`
  );
  
  // Performance summary
  parts.push(
    `Performance analysis indicates ${analysis.performance.complexity} complexity with an estimated ` +
    `execution time of ${analysis.performance.estimatedTime}.`
  );
  
  return parts.join(' ');
}
